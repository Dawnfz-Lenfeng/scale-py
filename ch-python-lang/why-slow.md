Python 性能瓶颈原因
-------------------

Python 虽然被广泛使用，但却一直被诟病速度慢。主要由于以下几个原因：

* 解释型语言
* 动态类型
* 全局解释器锁

### 解释型语言

Python 是一种解释型语言。Python 程序在运行时需要一个解释器将代码转换为机器能理解的语言。相比之下，像 C++ 这样的编译型语言在程序运行之前就已经被编译为机器代码，这通常会导致更好的性能。

编译型语言先用编译器把源代码编译成可执行文件，然后再运行这个可执行文件。如果拿翻译来类比的话，编译型语言将稿子翻译好（用编译器把源代码编译成可执行文件），然后再直接拿过来读（运行可执行文件）。解释型语言没有编译的过程，直接可以运行源代码。如果拿翻译来类比的话，就像“同声传译”去翻译一段话，一边接受信息，一边翻译。

### 动态类型

Python 是动态类型的语言。在编写源代码时，不需要给变量指定具体的类型（`int`、`float` 等），而且源代码中可随便切换变量的类型。这虽然方便了程序员编写代码，但却带来了额外的性能开销。解释器无法提前知道要进行的计算是什么类型的，直到运行时才能去检查类型，并调用背后相应的计算。类似的操作如果累积起来，会产生一定性能开销。相比之下，静态类型的语言如 C++，变量的类型在编译时就已经确定，无需运行时的类型检查等操作。

### 全局解释器锁

Python 语言一个广为诟病的问题是全局解释器锁（Global Interpreter Lock，GIL）。GIL使得很多 Python 代码无法充分利用现代 CPU 的多核，比如一些 pandas 操作无法充分使用多核。

GIL 是 CPython 中实现的一种同步机制，用来防止多个线程同时执行 Python 程序。CPython 是 Python 语言的默认实现，也是最广泛使用的实现。它是用 C 语言编写的，因此得名 CPython。当人们在没有特别指明的情况下谈论“Python”，通常是指 CPython。除了 CPython，还有一些其他的 Python 实现，如 Jython（用 Java 实现的 Python）、IronPython（用 .NET 实现的 Python）等。这些实现都遵循同样的 Python 语言规范，但可能在性能、兼容性和可用的库等方面有所不同。

GIL 名称中带 “锁” 这个字，也就是说它给多线程实现加了一把锁。GIL 这种机制确保了任何时候都只有一个线程在执行，从而避免了多线程之间的数据竞争和状态不一致的问题。然而，在当前主流的多核 CPU 处理器上，CPython 不能利用多个核心进行并行计算，这对于很多计算密集的应用来是一个瓶颈。
